<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>鱼的记忆</title>

  
  <meta name="author" content="比特鱼">
  

  
  <meta name="description" content="一些速记与思考，避免知识的遗忘">
  

  
  <meta name="keywords" content="Kubernetes, Kubeflow, Golang, Java">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="鱼的记忆"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="鱼的记忆" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">鱼的记忆</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/passages/RocksDB读优化/"><span>RocksDB 读优化</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/RocksDB读优化/" rel="bookmark">
        <time class="entry-date published" datetime="2024-02-24T11:23:22.000Z">
          2024-02-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="RocksDB-MultiGet-优化"><a href="#RocksDB-MultiGet-优化" class="headerlink" title="RocksDB MultiGet 优化"></a>RocksDB MultiGet 优化</h2><p>去年的工作内容中涉及到RocksDB的读写优化，场景分为：大批量写；批量只读；读写TTL</p>
<p>本文回顾批量只读场景下的优化思路，以及记录未来的计划</p>
<h2 id="RocksDB-简单介绍"><a href="#RocksDB-简单介绍" class="headerlink" title="RocksDB 简单介绍"></a>RocksDB 简单介绍</h2><p>RocksDB 是一个基于LevelDB优化的持久化KV数据库，其存储结构是LSM-Tree，主要设计用来应对写入密集型工作负载</p>
<h2 id="第一个问题，技术选型"><a href="#第一个问题，技术选型" class="headerlink" title="第一个问题，技术选型"></a>第一个问题，技术选型</h2><p>技术选型阶段，我们遇到一个问题，天生为写优化的RocksDB在只读场景是否有必要采用呢？</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/KV数据库/">KV数据库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/C/">C++</a><a href="/tags/RocksDB/">RocksDB</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/golang-cpu-profile/"><span>golang-cpu-profile</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/golang-cpu-profile/" rel="bookmark">
        <time class="entry-date published" datetime="2022-11-21T15:26:00.000Z">
          2022-11-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="用pprof排查CPU-Killer"><a href="#用pprof排查CPU-Killer" class="headerlink" title="用pprof排查CPU Killer"></a>用pprof排查CPU Killer</h1><h2 id="故障背景"><a href="#故障背景" class="headerlink" title="故障背景"></a>故障背景</h2><p>最近新上线了一个微服务，主要功能是定期执行各种定时任务，其中一个任务涉及到持有Redis分布式锁，并通过time.Ticker自动续期。（看到这里，也许你已经猜到了问题根源）。</p>
<p>这个服务上线以后，没有出什么大问题，每个任务都按照预期在规定时间内完成。然而，随着时间的推移，任务开始出现超时，甚至有的时候进程已经卡顿到连相关指标监控都无法获取。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/Golang/">Golang</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Golang/">Golang</a><a href="/tags/pprof/">pprof</a><a href="/tags/profile/">profile</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/Golang的协程同步/"><span>Golang的协程同步</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/Golang的协程同步/" rel="bookmark">
        <time class="entry-date published" datetime="2020-01-25T16:08:16.000Z">
          2020-01-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近遇到了一个BUG，由于对Golang的同步模型理解不够深入所导致的资源泄露。</p>
<p>伪代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res Connection</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">	res, err := acquire(<span class="number">200</span> * time.Millisecond) <span class="comment">//计数器递增</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;err: %v&quot;</span>, err) <span class="comment">//第7行，这里报错</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	doWork(res)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> &lt;-done:</span><br><span class="line"> <span class="keyword">case</span> &lt;-time.After(<span class="number">300</span> * time.Millisecond):</span><br><span class="line">&#125;</span><br><span class="line">release(res) <span class="comment">//如果res不等于nil，计数器递减</span></span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/Golang/">Golang</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Golang/">Golang</a><a href="/tags/内存模型/">内存模型</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/hdfs-proxy/"><span>hdfs-proxy</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/hdfs-proxy/" rel="bookmark">
        <time class="entry-date published" datetime="2019-12-23T14:23:26.000Z">
          2019-12-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="HDFS-Proxy-技术梳理"><a href="#HDFS-Proxy-技术梳理" class="headerlink" title="HDFS-Proxy 技术梳理"></a>HDFS-Proxy 技术梳理</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>来自某个需求，希望数据平台可以支持多个不同版本不同认证方式的Hadoop集群。</p>
<p>由于Kerberos的认证是进程级别有效的，因此无法在多线程环境下支持对多Hadoop集群的访问支持。</p>
<p>为了解决多个模块对HDFS的访问需求，因此设计HDFS Proxy模块，透明无侵入地解决这个问题。</p>
<h2 id="设计目标（按重要性排序）"><a href="#设计目标（按重要性排序）" class="headerlink" title="设计目标（按重要性排序）"></a>设计目标（按重要性排序）</h2><ol>
<li>兼容FileSystem接口，尽量减少接入方的改动成本</li>
<li>保证性能，减少Proxy环节的性能损耗</li>
<li>可扩展性，对于集群数量与流量负载都能保持线性可扩展</li>
<li>完整的Log&#x2F;Tracing&#x2F;Metrics信息，减少服务运行状态的不透明</li>
<li>保持异常信息，在客户端还原服务端捕获到的异常</li>
<li>不保证线程安全，虽然有一定的锁保护，但不支持多线程同时访问一个FS实例</li>
</ol>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/Java/">Java</a>, <a href="/categories/技术/Java/Hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a><a href="/tags/大数据/">大数据</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/java-nio-wakeup-trick/"><span>java-nio-wakeup-trick</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/java-nio-wakeup-trick/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-01T14:02:53.000Z">
          2019-07-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="探索NIO-wakeup内部原理"><a href="#探索NIO-wakeup内部原理" class="headerlink" title="探索NIO wakeup内部原理"></a>探索NIO wakeup内部原理</h1><p>最近在重新梳理对Kafka的知识，看一遍源码加深印象。源码实现中，Kafka的客户端与服务端都是基于Java NIO机制提高网络IO的效率（当然，这不是唯一因素）。</p>
<p>这里就不再重复说明阻塞&#x2F;非阻塞，同步&#x2F;异步IO模型之间的区别了，也不赘述非阻塞IO在不同平台上的实现，例如select，epoll，kqueue等，这些都可以在网络上找到很丰富的文档以及示例。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a><a href="/tags/NIO/">NIO</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/golang-memory-leak-failure/"><span>golang-memory-leak-failure</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/golang-memory-leak-failure/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-25T18:03:23.000Z">
          2019-06-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="一次不成功的Golang内存溢出排查"><a href="#一次不成功的Golang内存溢出排查" class="headerlink" title="一次不成功的Golang内存溢出排查"></a>一次不成功的Golang内存溢出排查</h1><p>我们的监控服务是以Prometheus加K8S为基础搭建的，运行一段时间后出现了内存溢出的现象，内存RSS占用高达9G，CPU占用60%。以下是整理的排查思路</p>
<h2 id="PProf排查："><a href="#PProf排查：" class="headerlink" title="PProf排查："></a>PProf排查：</h2><p>我们先查看了应用日志，这些日志内容不断重复，有一定规律，但是当时暂时没有发现特别之处。</p>
<p><img src="/images/memleak-log.png" alt="memleak-log"></p>
<p>接下来，针对Go应用的内存泄露问题，想到了通过官方PProf工具收集应用信息。幸好，Prometheus开启了PProf接口，因此我们可以很方便的得到协程与内存信息。具体过程不表，结果如下：</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/Golang/">Golang</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Golang/">Golang</a><a href="/tags/MemoryLeak/">MemoryLeak</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/redis-cluster-specification/"><span>redis-cluster-specification</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/redis-cluster-specification/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-21T13:45:35.000Z">
          2019-06-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Redis集群规范（译）"><a href="#Redis集群规范（译）" class="headerlink" title="Redis集群规范（译）"></a>Redis集群规范（译）</h1><p>欢迎来到<a href="https://redis.io/topics/cluster-spec"><strong>Redis集群规范</strong></a>。在这里，你可以了解到Redis集群的算法和设计原理。这篇文档还在持续改进过程中，与Redis集群的具体实现保持一致。</p>
<h2 id="主要目标与设计原理"><a href="#主要目标与设计原理" class="headerlink" title="主要目标与设计原理"></a>主要目标与设计原理</h2><h3 id="Redis集群设计目标"><a href="#Redis集群设计目标" class="headerlink" title="Redis集群设计目标"></a>Redis集群设计目标</h3><p>Redis集群是Redis的分布式实现，主要有如下几个目标，按照重要性依次排列：</p>
<ul>
<li>高性能以及线性扩展到1000个节点。不使用代理，主从间采用异步复制，并且不支持冲突值的合并操作。</li>
<li>可接受程度的写安全性：当（发生网络分区）客户端可以与系统多数派主节点保持联系时，系统会（尽最大努力）尝试保留来自客户端的所有写数据。通常情况下，可能会有一个小窗口时间内的写数据会丢失。当节点处于少数派网络分区时，这个丢失数据的时间窗口会变得更大。</li>
<li>可用性：当发生网络分区时，如果大多数主节点都可用，并且那些不可用的主节点都至少有一个可用的从节点，那么Redis集群仍然可以保持可用。而且通过<strong>从节点迁移</strong>命令，可以将具有多个从节点的主节点的从节点分配给没有从节点的主节点。</li>
</ul>
<p>本文档描述的内容在Redis3.0以及更高版本中实现。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/分布式理论/">分布式理论</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a><a href="/tags/distribution/">distribution</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/arthas-first-parctice/"><span>arthas-first-parctice</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/arthas-first-parctice/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-09T06:55:32.000Z">
          2019-06-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Arthas-在线诊断初体验"><a href="#Arthas-在线诊断初体验" class="headerlink" title="Arthas 在线诊断初体验"></a>Arthas 在线诊断初体验</h1><p><a href="https://alibaba.github.io/arthas/">Arthas</a> 是一款阿里出品的Java诊断工具，可以实时监控JVM状态，灵活地线上Debug，具体可以看看它的教程。</p>
<p>虽然功能很强大，但是这次需要排查的问题比较简单，使用watch命令就简单搞定了。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/Debug/">Debug</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a><a href="/tags/Debug/">Debug</a><a href="/tags/Arthas/">Arthas</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/coursera-cloud-computing-specialization/"><span>coursera-cloud-computing-specialization</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/coursera-cloud-computing-specialization/" rel="bookmark">
        <time class="entry-date published" datetime="2019-06-02T22:02:53.000Z">
          2019-06-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>两个月前，机缘巧合之下看到了Coursera上的专项付费系列：<a href="https://www.coursera.org/specializations/cloud-computing">云计算 专项</a>。这个系列包含六门课程，主要是讲解了云计算的基础概念，理论，实现和应用。如果你有志于云计算&#x2F;分布式开发，而且有一定的编程经验（C++与Python），这个系列的课程很适合你。至于我，其实已经从业五年了，重新夯实基础，补齐理论知识是我的主要目的。这个课程的编程题都不难，写的水一些，不用太考虑完美，都能拿到（编程题部分的）满分。</p>
<p>学了一个月多，快把这六门课都学完了，在此记录一下自己的心得体会。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/个人发展/">个人发展</a>, <a href="/categories/个人发展/专业技能/">专业技能</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/distributed/">distributed</a><a href="/tags/cloud/">cloud</a><a href="/tags/coursera/">coursera</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/passages/paxos-simpliy/"><span>paxos-simpliy</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/passages/paxos-simpliy/" rel="bookmark">
        <time class="entry-date published" datetime="2019-05-01T17:15:19.000Z">
          2019-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Paxos-Made-Simple-读后感"><a href="#Paxos-Made-Simple-读后感" class="headerlink" title="Paxos Made Simple 读后感"></a>Paxos Made Simple 读后感</h2><p>近来在Cousera上学习 <a href="https://www.coursera.org/specializations/cloud-computing">Cloud Computing Concept Part 1</a>，其中涉及到了对Paxos算法的介绍。Paxos算法固然是比较难懂的，但是幸好有简化版论文 <a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/past/03F/notes/paxos-simple.pdf?spm=a2c4e.11153940.blogcont85470.8.76e44d9eRGbB30&file=paxos-simple.pdf">Paxos Made Simple</a>，相对好理解很多，分享一下自己的理解。</p>
<h2 id="Paxos算法的问题背景"><a href="#Paxos算法的问题背景" class="headerlink" title="Paxos算法的问题背景"></a>Paxos算法的问题背景</h2><p>分布式系统进程模型：多个分布式进程节点，彼此只能通过网络消息通信；整个系统是异步的，时钟可能不同步，时间流速也可能不同，消息可能丢失，乱序到达，也可能无限延迟，任一进程可能失败退出（但是至少超过半数节点存活并可以互相通信）。</p>
<p>分布式一致性问题：分布式系统中每个进程都有一个变量y，最初处于为未初始化状态，一旦变量y的值被确定，就不允许被修改；经过有限步骤，使得所有活着的进程都确定同一个y值，这就是一致性问题</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/技术/">技术</a>, <a href="/categories/技术/分布式理论/">分布式理论</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/distributed/">distributed</a><a href="/tags/consensus/">consensus</a><a href="/tags/paxos/">paxos</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 比特鱼
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>